<?php

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

namespace Cogitoweb\MultiLevelAdminBundle\Admin;

use Doctrine\Common\Inflector\Inflector;
use Sonata\AdminBundle\Admin\AbstractAdmin as SonataAbstractAdmin;
use Sonata\AdminBundle\Admin\AdminInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

/**
 * Description of AbstractAdmin
 *
 * @author Daniele Artico <daniele.artico@cogitoweb.it>
 */
class AbstractAdmin extends SonataAbstractAdmin
{
	/**
	 * Regular expression to obtain informations from Admin class
	 * 
	 * @const ADMIN_CLASS_REGEX
	 */
	const ADMIN_CLASS_REGEX = '@(?:([A-Za-z0-9]*)\\\)?(Bundle\\\)?([A-Za-z0-9]+?)(?:Bundle)?\\\(Admin)\\\(.*)Admin@';

	/**
	 * The cached base route name.
	 * 
	 * @var string
	 */
	protected $cachedBaseRouteName;

	/**
	 * The cached base route pattern.
	 * 
	 * @var string
	 */
	protected $cachedBaseRoutePattern;

	/**
	 * Add parent Admin
	 * 
	 * @param AdminInterface $parent
	 */
	public function addParent(AdminInterface $parent)
	{
		$parent->addChild($this);
		$this->setCurrentChild(true);
	}

	/**
	 * {@inheritdoc}
	 */
	public function getBaseCodeRoute()
	{
		/**
		 * Cogitoweb: the baseCodeRoute of children Admins can be incomplete,
		 * because the Admin instance available in {@see \Sonata\AdminBundle\Admin\Admin::addChild()} is not aware of its parent.
		 * Therefore the generated baseCodeRoute consists of current Admin code and its child code only.
		 * 
		 * Example
		 * Consider the Admins hierarchy "acme.admin.first > acme.admin.second > acme.admin.third > acme.admin.fourth".
		 * The baseCodeRoute generated by ThirdAdmin->addChild(FourthAdmin)
		 * is "acme.admin.third|acme.admin.fourth" instead of "acme.admin.first|acme.admin.second|acme.admin.third|fourth".
		 * 
		 * Current override fix that.
		 */

		$hierachy = $this->getHierachy();

		// Get Admin codes from hierachy
		$codes = array_map(function (AdminInterface $admin) { return $admin->getCode(); }, $hierachy);

		// Generate baseCodeRoute
		$this->baseCodeRoute = implode('|', $codes);

		return $this->baseCodeRoute;
	}

	/**
	 * {@inheritdoc}
	 */
	public function getBaseRouteName()
	{
		if (null !== $this->cachedBaseRouteName) {
			return $this->cachedBaseRouteName;
		}

		if ($this->isChild()) { // the admin class is a child, prefix it with the parent route name
			if (!$this->baseRouteName) {
				/**
				 * Cogitoweb: due to {@see Cogitoweb\MultiLevelAdminBundle\Admin\Pool::getAdminByClass()},
				 * it is not possible to rely on class name to generate routes,
				 * because 2 Admins sharing the same class would generate the same routes,
				 * making impossible for Symfony to determine which Admin has to be served to satisfy a user request.
				 * 
				 * Example
				 * App\AcmeBundle\Admin\FirstAdmin and App\AcmeBundle\Admin\FirstSiblingAdmin Admins are associated to App\AcmeBundle\Entity\First.
				 * SonataAdmin generates the following routes for both Admins:
				 * - /admin/app/first/list
				 * - /admin/app/first/create
				 * - /admin/app/first/{id}/show
				 * - ...
				 * When Symfony receives a request matching the route /admin/app/first/create,
				 * it cannot determine which Admin to serve.
				 * 
				 * The workaround is to use Admin class name instead.
				 * By consequence, SonataAdmin generates a different set of routes for each Admin.
				 * 
				 * Example
				 * App\AcmeBundle\Admin\FirstAdmin and App\AcmeBundle\Admin\FirstSiblingAdmin Admins are associated to App\AcmeBundle\Entity\First.
				 * SonataAdmin generates the following routes:
				 * - /admin/app/first/list
				 * - /admin/app/first/create
				 * - /admin/app/first/{id}/show
				 * - ...
				 * - /admin/app/firstsibling/list
				 * - /admin/app/firstsibling/create
				 * - /admin/app/firstsibling/{id}/show
				 * - ...
				 * When Symfony receives a request matching the route /admin/app/first/create,
				 * it can exactly determine which Admin to serve.
				 */
//				preg_match(self::CLASS_REGEX, $this->class, $matches);
				preg_match(self::ADMIN_CLASS_REGEX, get_class($this), $matches);

				if (!$matches) {
					throw new \RuntimeException(sprintf('Cannot automatically determine base route name, please define a default `baseRouteName` value for the admin class `%s`', get_class($this)));
				}
			}

			$this->cachedBaseRouteName = sprintf('%s_%s',
				$this->getParent()->getBaseRouteName(),
				$this->baseRouteName ?: $this->urlize($matches[5])
			);
        } elseif ($this->baseRouteName) {
			$this->cachedBaseRouteName = $this->baseRouteName;
		} else {
			// Cogitoweb
//			preg_match(self::CLASS_REGEX, $this->class, $matches);
			preg_match(self::ADMIN_CLASS_REGEX, get_class($this), $matches);

			if (!$matches) {
				throw new \RuntimeException(sprintf('Cannot automatically determine base route name, please define a default `baseRouteName` value for the admin class `%s`', get_class($this)));
			}

			$this->cachedBaseRouteName = sprintf('admin_%s%s_%s',
				empty($matches[1]) ? '' : $this->urlize($matches[1]).'_',
				$this->urlize($matches[3]),
				$this->urlize($matches[5])
			);
		}

		return $this->cachedBaseRouteName;
	}

	/**
	 * {@inheritdoc}
	 */
	public function getBaseRoutePattern()
	{
		if (null !== $this->cachedBaseRoutePattern) {
			return $this->cachedBaseRoutePattern;
		}

		if ($this->isChild()) { // the admin class is a child, prefix it with the parent route pattern
            if (!$this->baseRoutePattern) {
				/**
				 * Cogitoweb: {@see getBaseRouteName()} for further informations
				 */
//				preg_match(self::CLASS_REGEX, $this->class, $matches);
				preg_match(self::ADMIN_CLASS_REGEX, get_class($this), $matches);

                if (!$matches) {
                    throw new \RuntimeException(sprintf('Please define a default `baseRoutePattern` value for the admin class `%s`', get_class($this)));
                }
			}

			// Cogitoweb: use router id parameter instead of "id"
//			$this->cachedBaseRoutePattern = sprintf('%s/{id}/%s',
//				$this->getParent()->getBaseRoutePattern(),
//				$this->baseRoutePattern ?: $this->urlize($matches[5], '-')
//			);
			$this->cachedBaseRoutePattern = sprintf('%s/%s/%s',
				$this->getParent()->getBaseRoutePattern(),
				$this->getParent()->getRouterIdParameter(),
				$this->baseRoutePattern ?: $this->urlize($matches[5], '-')
			);
		} elseif ($this->baseRoutePattern) {
			$this->cachedBaseRoutePattern = $this->baseRoutePattern;
		} else {
			// Cogitoweb
//			preg_match(self::CLASS_REGEX, $this->class, $matches);
			preg_match(self::ADMIN_CLASS_REGEX, get_class($this), $matches);
				if (!$matches) {
				throw new \RuntimeException(sprintf('Please define a default `baseRoutePattern` value for the admin class `%s`', get_class($this)));
			}
				$this->cachedBaseRoutePattern = sprintf('/%s%s/%s',
				empty($matches[1]) ? '' : $this->urlize($matches[1], '-').'/',
				$this->urlize($matches[3], '-'),
				$this->urlize($matches[5], '-')
			);
		}

		return $this->cachedBaseRoutePattern;
	}

	/**
	 * Returns the parameter representing request id, ie: id or childId.
	 * 
	 * @param  integer $nestingDepth
	 * 
	 * @return string
	 */
	public function getIdParameter()
	{
		$nestingDepth = $this->getNestingDepth();

		switch ($nestingDepth) {
			case 1:
				return 'id';
			case 2:
				return 'firstChildId';
			case 3:
				return 'secondChildId';
			case 4:
				return 'thirdChildId';
			case 5:
				return 'fourthChildId';
			case 6:
				return 'fifthChildId';
			case 7:
				return 'sixthChildId';
			case 8:
				return 'seventhChildId';
			case 9:
				return 'eighthChildId';
			case 10:
				return 'ninethChildId';
			case 11:
				return 'tenthChildId';
			default:
				$code = $this->getCode();

				throw new \OutOfBoundsException(sprintf('Admin "%s" exceeded max nesting depth limit.', $code));
		}
	}

	/**
	 * {@inheritdoc}
	 */
	public function getRouterIdParameter()
	{
		return sprintf('{%s}', $this->getIdParameter());
	}

	/**
	 * {@inheritdoc}
	 */
	public function generateObjectUrl($name, $object, array $parameters = array(), $absolute = false)
	{
		// Cogitoweb: use actual Admin id parameter
//		$parameters['id'] = $this->getUrlsafeIdentifier($object);
		$idParameter = $this->getIdParameter();
		$id          = $this->getUrlsafeIdentifier($object);

		$parameters[$idParameter] = $id;

		/*
		 * Cogitoweb: append parent object id to route parameters
		 * because it is needed to generate object routes in list view,
		 * and it's not possible to get it from the request.
		 */
		$parentObject = $this->getParentSubject($object);

		if ($parentObject) {
			$parent            = $this->getParent();
			$parentIdParameter = $parent->getIdParameter();
			$parentId          = $parent->getUrlsafeIdentifier($parentObject);

			$parameters[$parentIdParameter] = $parentId;
		}

		return $this->generateUrl($name, $parameters, $absolute);
	}

	/**
	 * {@inheritdoc}
	 */
	public function generateUrl($name, array $parameters = array(), $absolute = UrlGeneratorInterface::ABSOLUTE_PATH)
	{
		// Cogitoweb: append parent Admins id to route parameters
		if ($this->hasRequest()) {
			$hierarchy  = $this->getHierachy();
			$attributes = $this->getRequest()->attributes;

			// Cogitoweb: no need to append 
			array_pop($hierarchy);

			foreach ($hierarchy as $parentAdmin) {
				$idParameter = $parentAdmin->getIdParameter();

				if ($attributes->has($idParameter)) {
					$id = $attributes->get($idParameter);

					$parameters[$idParameter] = $id;
				}
			}
		}

		return $this->routeGenerator->generateUrl($this, $name, $parameters, $absolute);
	}

	/**
	 * {@inheritdoc}
	 */
	public function getCurrentChildAdmin()
	{
		foreach ($this->children as $child) {
			if ($child->getCurrentChild()) {
				$grandChild = $child;

				if ($child->hasChildren()) {
					$grandChild = $child->getCurrentChildAdmin();
				}

				return $grandChild;
			}
		}

		return null;
	}

	/**
	 * {@inheritdoc}
	 */
	public function showIn($context)
	{
		/*
		 * Cogitoweb: do not show child Admins in dashboard or menu,
		 * because Sonata tries to resolve child Admins routes with no routing parameters available, and it crashes.
		 * 
		 * Example
		 * Sonata tries to show Admin "Third" list with route /admin/app/first/{id}/second/{firstChildId}/third/list,
		 * but it cannot get "id" and "firstChildId" routing parameters.
		 * 
		 * This fix solves the same issue in add_block TWIG template.
		 */
		if ($this->isChild()) {
			return false;
		}

		return parent::showIn($context);
	}
    /**
     * Get request from parents
     * 
     * @return Request|null
     */
    public function getRequestFromParents()
	{
		$hierachy = $this->getHierachy();

		foreach ($hierachy as $admin) {
			if ($admin->hasRequest()) {
				return $admin->getRequest();
			}
		}

		return null;
    }

	/**
	 * Get Admins hierachy
	 * 
	 * @return AdminInterface[]
	 */
	public function getHierachy()
	{
		$hierachy = array();

		$hierachy[] = $this;

		$parent = $this->getParent();

		while ($parent) {
			$hierachy[] = $parent;
			$parent     = $parent->getParent();
		}

		$hierachy = array_reverse($hierachy);

		return $hierachy;
	}

	/**
	 * Get nesting depth
	 * 
	 * @param int $depth
	 * 
	 * @return int
	 */
	protected function getNestingDepth()
	{
		$hierachy     = $this->getHierachy();
		$nestingDepth = count($hierachy);

		return $nestingDepth;
	}

	/**
	 * Get parent subject
	 * 
	 * @param mixed $object
	 * 
	 * @return mixed|null
	 */
	protected function getParentSubject($object)
	{
		if (!$this->isChild() || !$this->getParentAssociationMapping()) {
			return null;
		}

		$fieldName = $this->getParentAssociationMapping();
		$fieldName = Inflector::camelize($fieldName);
		$getField  = 'get' . $fieldName;

		if (method_exists($object, $getField)) {
			return $object->$getField();
		}

		return null;
	}
}